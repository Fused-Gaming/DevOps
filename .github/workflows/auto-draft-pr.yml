name: CI/CD Failure Monitor

# Monitor CI/CD results for claude/* branches
# Create issues for failures with troubleshooting information
# NO AUTOMATIC PR CREATION

on:
  push:
    branches:
      - 'claude/**'

permissions:
  contents: read
  issues: write
  actions: read

jobs:
  monitor-failures:
    name: üîç Monitor CI/CD Failures
    runs-on: ubuntu-latest
    # Only run if not on main/develop
    if: github.ref != 'refs/heads/main' && github.ref != 'refs/heads/develop'

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ‚è≥ Wait for CI/CD Pipeline
        id: wait_ci
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚Üí Waiting for CI/CD pipeline to complete..."
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

          BRANCH_NAME="${{ github.ref_name }}"
          COMMIT_SHA="${{ github.sha }}"

          # Wait up to 10 minutes for workflow to start and complete
          MAX_WAIT=600
          ELAPSED=0
          INTERVAL=30

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # Get workflow runs for this commit
            RUNS=$(gh api "/repos/${{ github.repository }}/actions/runs?head_sha=$COMMIT_SHA" --jq '.workflow_runs[] | select(.name == "Enhanced CI/CD Pipeline") | {id: .id, status: .status, conclusion: .conclusion}')

            if [ -n "$RUNS" ]; then
              STATUS=$(echo "$RUNS" | jq -r '.status' | head -1)
              CONCLUSION=$(echo "$RUNS" | jq -r '.conclusion' | head -1)
              RUN_ID=$(echo "$RUNS" | jq -r '.id' | head -1)

              echo "  Status: $STATUS | Conclusion: $CONCLUSION"

              if [ "$STATUS" == "completed" ]; then
                echo "workflow_completed=true" >> $GITHUB_OUTPUT
                echo "workflow_conclusion=$CONCLUSION" >> $GITHUB_OUTPUT
                echo "workflow_run_id=$RUN_ID" >> $GITHUB_OUTPUT
                echo "‚úì CI/CD pipeline completed with conclusion: $CONCLUSION"
                break
              fi
            fi

            echo "  Waiting... ($ELAPSED/$MAX_WAIT seconds)"
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo "workflow_completed=timeout" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Timeout waiting for CI/CD pipeline"
          fi

      - name: üìä Analyze Failures
        id: analyze_failures
        if: steps.wait_ci.outputs.workflow_completed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚Üí Analyzing CI/CD failures..."
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

          RUN_ID="${{ steps.wait_ci.outputs.workflow_run_id }}"
          CONCLUSION="${{ steps.wait_ci.outputs.workflow_conclusion }}"

          if [ "$CONCLUSION" != "failure" ]; then
            echo "‚úì No failures detected - CI/CD passed!"
            echo "has_failures=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "has_failures=true" >> $GITHUB_OUTPUT

          # Get job details
          JOBS=$(gh api "/repos/${{ github.repository }}/actions/runs/$RUN_ID/jobs" --jq '.jobs[]')

          FAILURE_SUMMARY=""
          SECURITY_FAILURES=""
          BUILD_FAILURES=""
          TEST_FAILURES=""
          OTHER_FAILURES=""

          echo "$JOBS" | jq -r 'select(.conclusion == "failure") | "\(.name)|\(.id)"' | while IFS='|' read -r job_name job_id; do
            echo "  ‚ùå Failed: $job_name"

            # Get job logs to extract failure reasons
            LOG_OUTPUT=$(gh api "/repos/${{ github.repository }}/actions/jobs/$job_id/logs" 2>&1 || echo "")

            # Categorize failures
            if [[ "$job_name" == *"Security"* ]] || [[ "$job_name" == *"security"* ]]; then
              SECURITY_FAILURES="${SECURITY_FAILURES}\n### üîí Security Audit Failed\n"

              if echo "$LOG_OUTPUT" | grep -q "CRITICAL.*vulnerabilities"; then
                SECURITY_FAILURES="${SECURITY_FAILURES}- Critical vulnerabilities found in dependencies\n"
              fi
              if echo "$LOG_OUTPUT" | grep -q "secret.*detected\|.env.*tracked"; then
                SECURITY_FAILURES="${SECURITY_FAILURES}- Exposed secrets or credentials detected\n"
              fi

            elif [[ "$job_name" == *"Build"* ]] || [[ "$job_name" == *"build"* ]]; then
              BUILD_FAILURES="${BUILD_FAILURES}\n### üî® Build Failed\n"

              if echo "$LOG_OUTPUT" | grep -q "npm ERR!"; then
                BUILD_FAILURES="${BUILD_FAILURES}- npm build errors detected\n"
              fi
              if echo "$LOG_OUTPUT" | grep -q "SyntaxError\|TypeError"; then
                BUILD_FAILURES="${BUILD_FAILURES}- JavaScript/TypeScript errors found\n"
              fi

            elif [[ "$job_name" == *"Test"* ]] || [[ "$job_name" == *"test"* ]]; then
              TEST_FAILURES="${TEST_FAILURES}\n### üß™ Tests Failed\n"
              TEST_FAILURES="${TEST_FAILURES}- Test suite failures detected\n"

            else
              OTHER_FAILURES="${OTHER_FAILURES}\n### ‚ö†Ô∏è  $job_name Failed\n"
            fi
          done

          # Combine all failures
          FAILURE_SUMMARY="${SECURITY_FAILURES}${BUILD_FAILURES}${TEST_FAILURES}${OTHER_FAILURES}"

          echo "failure_summary<<EOF" >> $GITHUB_OUTPUT
          echo -e "$FAILURE_SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Determine if critical
          if [ -n "$SECURITY_FAILURES" ] || [ -n "$BUILD_FAILURES" ]; then
            echo "is_critical=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  CRITICAL failures detected"
          else
            echo "is_critical=false" >> $GITHUB_OUTPUT
          fi

      - name: üêõ Create Failure Issue
        id: create_issue
        if: steps.analyze_failures.outputs.has_failures == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚Üí Creating issue for CI/CD failure..."
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

          BRANCH_NAME="${{ github.ref_name }}"
          COMMIT_SHA="${{ github.sha }}"
          RUN_ID="${{ steps.wait_ci.outputs.workflow_run_id }}"
          IS_CRITICAL="${{ steps.analyze_failures.outputs.is_critical }}"

          # Check for existing open issue for this branch
          EXISTING_ISSUE=$(gh issue list --label "ci-failure" --label "claude-branch" --state open --search "in:title $BRANCH_NAME" --json number --jq '.[0].number' || echo "")

          if [ -n "$EXISTING_ISSUE" ]; then
            echo "‚ö†Ô∏è  Issue already exists: #$EXISTING_ISSUE"
            echo "   Updating existing issue..."

            cat > /tmp/issue_update.md << UPDATE_EOF
            ## üîÑ New Failure Detected

            **Commit:** \`$COMMIT_SHA\`
            **Time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
            **Workflow Run:** [View Logs](https://github.com/${{ github.repository }}/actions/runs/$RUN_ID)

            ### Failure Details

            ${{ steps.analyze_failures.outputs.failure_summary }}

            ---
            *Updated automatically by CI/CD Failure Monitor*
            UPDATE_EOF

            gh issue comment "$EXISTING_ISSUE" --body-file /tmp/issue_update.md
            echo "issue_number=$EXISTING_ISSUE" >> $GITHUB_OUTPUT
            echo "‚úì Updated existing issue #$EXISTING_ISSUE"

          else
            # Create new issue
            SEVERITY="‚ö†Ô∏è"
            PRIORITY="priority: medium"
            if [ "$IS_CRITICAL" == "true" ]; then
              SEVERITY="üö®"
              PRIORITY="priority: high"
            fi

            cat > /tmp/new_issue.md << ISSUE_EOF
            ## $SEVERITY CI/CD Pipeline Failure

            The CI/CD pipeline failed for branch \`$BRANCH_NAME\`.

            ### üìä Failure Information

            **Branch:** \`$BRANCH_NAME\`
            **Commit:** \`$COMMIT_SHA\`
            **Author:** @${{ github.actor }}
            **Time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
            **Workflow Run:** [View Detailed Logs](https://github.com/${{ github.repository }}/actions/runs/$RUN_ID)

            ### ‚ùå What Failed

            ${{ steps.analyze_failures.outputs.failure_summary }}

            ### üîß Troubleshooting Steps

            #### For Security Failures:
            1. Run \`npm audit\` locally to see all vulnerabilities
            2. Run \`npm audit fix\` to automatically fix issues
            3. For remaining issues, manually update packages
            4. Check for exposed secrets with \`git grep -E "(api[_-]?key|secret|password)"\`
            5. Remove any .env files from git tracking

            #### For Build Failures:
            1. Pull the latest changes: \`git pull origin $BRANCH_NAME\`
            2. Clean install dependencies: \`rm -rf node_modules && npm install\`
            3. Try building locally: \`npm run build\`
            4. Check for syntax errors in modified files
            5. Verify all imports and dependencies are correct

            #### For Test Failures:
            1. Run tests locally: \`npm test\`
            2. Review failing test output
            3. Update tests if behavior changed intentionally
            4. Fix code if tests caught a bug

            ### üìã Next Steps

            - [ ] Review the workflow logs linked above
            - [ ] Reproduce the failure locally
            - [ ] Fix the underlying issue
            - [ ] Push fixes to the branch
            - [ ] Verify CI/CD passes
            - [ ] Close this issue once resolved

            ### üîó Related Links

            - **Branch:** [\`$BRANCH_NAME\`](https://github.com/${{ github.repository }}/tree/$BRANCH_NAME)
            - **Commit:** [\`${COMMIT_SHA:0:7}\`](https://github.com/${{ github.repository }}/commit/$COMMIT_SHA)
            - **Workflow:** [Enhanced CI/CD Pipeline](https://github.com/${{ github.repository }}/actions/runs/$RUN_ID)

            ---
            *This issue was automatically created by the [CI/CD Failure Monitor](.github/workflows/auto-draft-pr.yml) workflow.*
            *To prevent automatic issue creation, fix the CI/CD failures before pushing.*
            ISSUE_EOF

            ISSUE_URL=$(gh issue create \
              --title "CI/CD Failure: $BRANCH_NAME" \
              --body-file /tmp/new_issue.md \
              --label "bug" \
              --label "ci-failure" \
              --label "claude-branch" \
              --label "$PRIORITY" \
              --label "needs-triage" \
              --assignee "${{ github.actor }}" \
              || echo "")

            if [ -n "$ISSUE_URL" ]; then
              ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -oP '\d+$')
              echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
              echo "‚úì Created issue #$ISSUE_NUMBER"
              echo "$ISSUE_URL"
            else
              echo "‚ùå Failed to create issue"
            fi
          fi

      - name: üìä Summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # üîç CI/CD Failure Monitor

          ## Configuration

          - **Branch:** `${{ github.ref_name }}`
          - **Triggered by:** @${{ github.actor }}
          - **Commit:** `${{ github.sha }}`
          - **Workflow:** CI/CD Failure Monitor

          ## Results

          | Check | Status |
          |-------|--------|
          | CI/CD Completed | ${{ steps.wait_ci.outputs.workflow_completed == 'true' && '‚úÖ Yes' || steps.wait_ci.outputs.workflow_completed == 'timeout' && '‚è±Ô∏è Timeout' || '‚è≥ Waiting' }} |
          | Failures Detected | ${{ steps.analyze_failures.outputs.has_failures == 'true' && '‚ùå Yes' || steps.analyze_failures.outputs.has_failures == 'false' && '‚úÖ No' || '‚ûñ N/A' }} |
          | Critical Failures | ${{ steps.analyze_failures.outputs.is_critical == 'true' && 'üö® Yes' || steps.analyze_failures.outputs.is_critical == 'false' && '‚ö†Ô∏è No' || '‚ûñ N/A' }} |
          | Issue Created | ${{ steps.create_issue.outputs.issue_number != '' && '‚úÖ Yes (#' || '‚ûñ Not needed' }}${{ steps.create_issue.outputs.issue_number }}${{ steps.create_issue.outputs.issue_number != '' && ')' || '' }} |

          ## Actions Taken

          ${{ steps.analyze_failures.outputs.has_failures == 'true' && '- üêõ Created/updated issue for CI/CD failure' || '- ‚úÖ No failures detected - CI/CD passed successfully!' }}
          ${{ steps.create_issue.outputs.issue_number != '' && '\n- üìã Issue #' || '' }}${{ steps.create_issue.outputs.issue_number }}${{ steps.create_issue.outputs.issue_number != '' && ' tracks this failure' || '' }}
          ${{ steps.analyze_failures.outputs.is_critical == 'true' && '\n- üö® **CRITICAL** - Immediate attention required' || '' }}

          ## Next Steps

          ${{ steps.analyze_failures.outputs.has_failures == 'true' && '1. Review the issue created for detailed troubleshooting steps\n2. Fix the failures locally\n3. Push fixes to the branch\n4. Verify CI/CD passes\n5. Close the issue once resolved' || '1. No action needed - all checks passed!\n2. Create a PR manually when ready\n3. Request review from team members' }}

          ---
          *Report generated at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')*
          *For help, see the issue created above or check workflow logs*
          EOF
